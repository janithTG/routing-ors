#!/usr/bin/env python3
"""
cleanup_outputs.py
Safely clean files generated by the warehouse relocation & routing apps.

Defaults:
- Only removes known output files (maps, charts, reports, solver/VRP CSVs)
- Moves them to a local ".cleanup_trash/<timestamp>/" folder (safe trash)
- Does NOT touch input files (deliveries.csv, skus.csv, locations.csv, days.csv, truck_types.csv, .env)

Usage:
  # Dry-run (show what would be removed)
  python cleanup_outputs.py

  # Move to .cleanup_trash (no prompts)
  python cleanup_outputs.py --yes

  # Permanently delete instead of trash
  python cleanup_outputs.py --yes --purge

  # Also remove input CSVs (deliveries.csv, skus.csv...) if you really want
  python cleanup_outputs.py --yes --include-inputs

  # Clean a different directory
  python cleanup_outputs.py --dir "C:/path/to/project" --yes
"""
from __future__ import annotations
import argparse
from datetime import datetime
from pathlib import Path
import shutil
import sys

# --- Known outputs (explicit names) ---
EXPLICIT_FILES = [
    # Routing (single-depot)
    "routes_summary.csv",
    "stops_assignment.csv",
    "routes_map.html",

    # Routing (compare two depots)
    "routes_summary_old.csv",
    "routes_summary_new.csv",
    "stops_assignment_old.csv",
    "stops_assignment_new.csv",
    "overall_comparison.csv",
    "routes_map_old.html",
    "routes_map_new.html",
    "routes_compare_map.html",
    "comparison_costs.png",
    "route_costs_old.png",
    "route_costs_new.png",
    "route_distance_hist_old.png",
    "route_distance_hist_new.png",
    "stop_distance_delta.csv",
    "stop_distance_delta.png",
    "stops_delta_map.html",
    "comparison_dashboard.html",

    # Relocation optimizer
    "slotting_plan.csv",
    "move_schedule_pallets.csv",
    "day_totals.csv",
    "Relocation_Report.xlsx",
    "Relocation_README.txt",
]

# --- Extra patterns (catch stragglers created by variations) ---
GLOB_PATTERNS = [
    "routes_summary_*.csv",
    "stops_assignment_*.csv",
    "routes_map_*.html",
    "route_costs_*.png",
    "route_distance_hist_*.png",
    "routes_*compare*.html",
    "comparison_*.png",
    "stop_*delta*.csv",
    "stop_*delta*.png",
    "stops_*map*.html",
]

# --- Optional input files (excluded by default; only removed with --include-inputs) ---
INPUT_FILES = [
    "deliveries.csv",
    "skus.csv",
    "locations.csv",
    "days.csv",
    "truck_types.csv",
    ".env",
]

def collect_targets(root: Path, include_inputs: bool) -> list[Path]:
    wanted = set()

    # Explicit names
    for name in EXPLICIT_FILES:
        p = root / name
        if p.exists():
            wanted.add(p)

    # Glob patterns
    for patt in GLOB_PATTERNS:
        for p in root.glob(patt):
            if p.is_file():
                wanted.add(p)

    # Optionally include input files
    if include_inputs:
        for name in INPUT_FILES:
            p = root / name
            if p.exists():
                wanted.add(p)
    else:
        # Ensure inputs are NOT in the list even if patterns matched
        for name in INPUT_FILES:
            p = root / name
            if p in wanted:
                wanted.remove(p)

    return sorted(wanted)

def move_to_trash(files: list[Path], root: Path) -> tuple[int, Path]:
    if not files:
        return 0, root
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    trash_dir = root / ".cleanup_trash" / ts
    trash_dir.mkdir(parents=True, exist_ok=True)
    count = 0
    for f in files:
        try:
            dest = trash_dir / f.name
            shutil.move(str(f), str(dest))
            count += 1
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not move {f.name}: {e}")
    return count, trash_dir

def purge(files: list[Path]) -> int:
    count = 0
    for f in files:
        try:
            f.unlink(missing_ok=True)
            count += 1
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not delete {f.name}: {e}")
    return count

def main():
    ap = argparse.ArgumentParser(description="Clean generated outputs from routing/relocation apps.")
    ap.add_argument("--dir", default=".", help="Directory to clean (default: current directory)")
    ap.add_argument("--dry-run", action="store_true", help="List files that would be removed (default behavior if --yes not set)")
    ap.add_argument("--yes", action="store_true", help="Do it (no interactive prompt)")
    ap.add_argument("--purge", action="store_true", help="Permanently delete instead of sending to .cleanup_trash")
    ap.add_argument("--include-inputs", action="store_true", help="Also remove input CSVs (.env, deliveries.csv, skus.csv, etc.)")
    args = ap.parse_args()

    root = Path(args.dir).resolve()
    if not root.exists():
        print(f"‚ùå Directory not found: {root}")
        sys.exit(2)

    targets = collect_targets(root, include_inputs=args.include_inputs)

    if not targets:
        print("Nothing to clean. (No generated files found.)")
        return

    rel = [str(p.relative_to(root)) for p in targets]
    print("The following files are selected for removal:")
    for r in rel:
        print("  -", r)

    # Default to dry-run unless --yes is passed
    if not args.yes and not args.dry_run:
        print("\n(no action taken) Tip: run with --yes to proceed, or --dry-run to just list.")
        return

    if args.dry_run and not args.yes:
        print("\nDry-run only. Nothing was removed.")
        return

    if args.purge:
        removed = purge(targets)
        print(f"üóëÔ∏è  Permanently deleted {removed} file(s).")
    else:
        removed, trash_dir = move_to_trash(targets, root)
        print(f"‚ôªÔ∏è  Moved {removed} file(s) to: {trash_dir}")

if __name__ == "__main__":
    main()
